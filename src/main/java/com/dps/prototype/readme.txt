注意事项的：　　

　　对象拷贝时，类的构造函数是不会被执行的。
   一个实现了 Cloneable 并重写了 clone 方法的类 A,有一个无参构造或有参构造 B，通过 new 关键字产生了一个对象 S，再然后通过 S.clone()方式产生了一个新的对象 T，那么在对象拷贝时构造函数 B 是不会被执行的， 对象拷贝时确实构造函数没有被执行。
   这个从原理来讲也是可以讲得通的，Object 类的 clone 方法的 原理是从内存中（具体的说就是堆内存）以二进制流的方式进行拷贝，重新分配一个内存块，那构造函数 没有被执行也是非常正常的了。

   final 类型修饰的成员变量不能进行深度拷贝。　　

   浅度克隆:Simple
       当被克隆的类中有引用对象（String或Integer等包装类型除外）时，克隆出来的类中的引用变量存储的还是之前的内存地址，也就是说克隆与被克隆的对象是同一个。
       这样的话两个对象共享了一个私有变量，所有人都可以改，是一个种非常不安全的方式，在实际项目中使用还是比较少的。

   深度克隆:Depth
   本体的引用类型应该复制一份给克隆体,而不仅仅是复制引用。



　　最后说一下，原型模式的使用场景

　　1、在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。

　　2、希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响）。

　　3、隐藏克隆操作的细节，很多时候，对对象本身的克隆需要涉及到类本身的数据细节。

　　4、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等；

　　5、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；

　　6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone的方法创建一个对象，然后由工厂方法提供给调用者。原型模式先产生出一个包含

　　大量共有信息的类，然后可以拷贝出副本，修正细节信息，建立了一个完整的个性对象。